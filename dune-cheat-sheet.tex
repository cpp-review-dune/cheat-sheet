\documentclass[landscape,a3paper]{article}

\usepackage{bold-extra}
\usepackage[margin=1.5mm]{geometry}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{multicol}
\usepackage{tikz}
\usepackage{xcolor}

\def\cxx{\lstinline[language=C++]}
\def\sh{\lstinline[language=sh]}
\lstset{basicstyle=\ttfamily}
\lstset{
  language=C++,
  defaultdialect=[11]C++,
  tabsize=4,
%  stringstyle=\ttfamily,
  keywordstyle=\color{violet},
  commentstyle=\color{darkgray},
  stringstyle=\color{orange},
  emph={bool,int,unsigned,char,true,false,void}, emphstyle=\color{blue},
  emph={[2]\#include,\#define,\#ifdef,\#endif}, emphstyle={[2]\color{violet}},
  emph={[3]stage}, emphstyle={[3]\color{purple}},
  extendedchars=true,
  escapechar=@,
  mathescape=true,
  escapebegin={\color{darkgray}},
  breaklines=false,
%  frame=lines,
%  backgroundcolor=\color{lightgray},
}

\setlength{\columnsep}{4mm}
\setlength{\columnseprule}{1pt}

\newcommand{\head}[1]{
  \par
  \tikz\node[text width=\linewidth-.6666em,align=justify,fill=lightgray]{#1};
  \par
}

\newcommand{\module}[1]{
  \par
  {%
    \huge\sffamily\bfseries%
    \tikz\node[
      text width=\linewidth-.6666em,
      align=justify,
      fill=black,
      text=white
    ]{\strut#1\strut};%
  }
  \par
}

\setlength\parindent{0pt}

\raggedcolumns

\begin{document}\begin{multicols*}{4}

\module{In General}

\head{\cxx{main()} template}
\begin{lstlisting}
#include <config.h>

#include <dune/common/parallel/mpihelper.hh>

int main(int argc, char **argv)
{
  Dune::MPIHelper::instance(argc, argv);

  // your code goes here
}
\end{lstlisting}

\head{\sh{.cc}-file template}
\begin{lstlisting}
#include <config.h>

// your code and includes go here
\end{lstlisting}

\head{\sh{.hh}-file template}
\begin{lstlisting}
// For a header that is included like
// #include <dune/module/dir/header-name.hh>
#ifndef DUNE_MODULE_DIR_HEADER_NAME_HH
#define DUNE_MODULE_DIR_HEADER_NAME_HH

// your code and includes go here
// do not #include <config.h>

#endif // DUNE_MODULE_DIR_HEADER_NAME_HH
\end{lstlisting}

\module{\cxx{dune-common}}

In the following, \cxx{r} is of type \cxx{R}, which may be a scalar real type,
e.g. \cxx{double} or \cxx{float}.  \cxx{k} is of type \cxx{K}, which may be
may be \cxx{R} or \cxx{std::complex<R>}.

\head{\cxx{template<class K, int size> class FieldVector;}}
\begin{lstlisting}
#include <dune/common/fvector.hh>

FieldVector<K, 2> x = { 0, 1 }; // $x_0:=0, x_1:=1$
FieldVector<K, 2> y(k);         // $x_i:=k\quad\forall i$

assert(i < x.dim()); // get number of entries
k = x[i]; x[i] = k;  // access/assign entry
for(const auto &entry : x)
  k += entry;        // access each entry
for(auto &entry : x)
  entry = k;         // modify each entry

x += y; x -= y; // $x:=x+y$, $x:=x-y$
x *= k; x /= k; // $x:=kx$, $x:=k^{-1}x$
k = x * y;      // $k:=x^Ty=x\cdot y=\sum_i x_iy_i$
k = x.dot(y);   // $k:=x^Hy=\bar x\cdot y=\sum_i\bar x_iy_i$

r = x.one_norm();      // $r:=\sum_i|x_i|$
r = x.two_norm();      // $r:=\smash{\sqrt{\sum_i|x_i|^2}}$
r = x.infinity_norm(); // $r:=\max_i\{|x_i|\}$
\end{lstlisting}
%r = x.two_norm2();     // $r:=\sum_i|x_i|^2$

\head{%
\cxx{template<class K, int rows, int cols>}
\cxx{class FieldMatrix;}
}
\begin{lstlisting}
#include <dune/common/fmatrix.hh>

FieldMatrix<K, 2, 2> S =
{ { 0, 1 },                // $S_{00}:=0,S_{01}:=1$
  { 2, 3 } };              // $S_{10}:=2,S_{11}:=3$
FieldMatrix<K, 2, 2> Q(k); // $Q_{ij}:=k\quad\forall i,j$

assert(i < S.rows()); // get number of rows
assert(j < S.cols()); // get number of columns
k = S[i][j];          // access entry
S[i][j] = k;          // assign entry
for(const auto &row : S)
  for(const auto &entry : row)
    k += entry;       // access each entry
for(auto &row : S)
  for(auto &entry : row)
    entry = k;        // modify each entry

auto L = Q.leftmultiplyany(S);  // $L:=SQ$
auto R = Q.rightmultiplyany(S); // $R:=QS$
Q.leftmultiply(S);              // $S:=SQ$
Q.rightmultiply(S);             // $S:=QS$
S += Q; S -= Q; // $S:=S+Q$, $S:=S-Q$
S.axpy(k, Q);   // $S:=S+kQ$
S *= k; S /= k; // $S:=kS$, $S:=k^{-1}S$
S.invert();     // $S:=S^{-1}$

r = S.frobenius_norm(); // $r:=\smash{\sqrt{\sum_{ij}|S_{ij}|^2}}$
r = S.infinity_norm();  // $r:=\smash{\max_i\{\sum_j|S_{ij}|\}}$
k = S.determinant();    // $k:=\det S$

Q.mv      (x, y); // $y:=Qx$
Q.mtv     (x, y); // $y:=Q^Tx$
Q.umv     (x, y); // $y:=y+Qx$
Q.umtv    (x, y); // $y:=y+Q^Tx$
Q.umhv    (x, y); // $y:=y+Q^Hx$
Q.usmv (k, x, y); // $y:=y+kQx$
Q.usmtv(k, x, y); // $y:=y+kQ^Tx$
Q.usmhv(k, x, y); // $y:=y+kQ^Hx$
Q.solve   (x, y); // find $x$ such that $Qx=y$
\end{lstlisting}

\head{\cxx{#define DUNE_THROW(ExceptionType, message)}}
\begin{lstlisting}
#include <dune/common/exceptions.hh>

if(i > limit)
  DUNE_THROW(Exception, "Error: i > limit ("
             << i << " > " << limit << ")");
\end{lstlisting}

\head{\cxx{template<class T> std::string className();}\\
\cxx{template<class T> std::string className(T& t);}}
\begin{lstlisting}
#include <dune/common/classname.hh>

template<class Vector>
void printTypes(const Vector &v) {
  std::cerr << "Info: Vector type is "
            << className<Vector>()
            << ", entry type is "
            << className(v[0]) << std::endl;
}
\end{lstlisting}

%\cxx{ParameterTree}

%\cxx{DynamicVector<T>} \cxx{DynamicMatrix<T>}
%\cxx{MPIHelper}

\module{\cxx{dune-geometry}}

\head{\cxx{class GeometryType;}}
\begin{lstlisting}
#include <dune/geometry/type.hh>

GeometryType gt;
gt.makeVertex();     gt.makeLine();
gt.makeTriangle();   gt.makeQuadrilateral();
gt.makeTetrahdron(); gt.makePyramid();
gt.makePrism();      gt.makeHexahedron();
gt.makeSimplex(2); // same as makeTriangle()
gt.makeCube(3);    // same as makeHexahedron()
// for each make@\itshape Shape@() there is an is@\itshape Shape@()
assert(gt.isHexahedron());
assert(gt.isCube());   // ignore dimension
assert(gt.dim() == 3); // check dimension
\end{lstlisting}

%\cxx{LocalGeometryTypeIndex} \cxx{GlobalGeometryTypeIndex}

\cxx{QuadratureRules<ctype, dim>::rule()}

\cxx{ReferenceElements<ctype, dim>}

Virtual refinement

topologies

geometry interface

\module{\cxx{dune-grid}}

grid interface -> \{ gridview -> \{ iteration: \{ entities<0>, entities,
      intersection*s \} -> geometries, indexsets \}, idsets, partitions \}

backuprestore

seeds

mapper: mcmg, scsg, universal

\cxx{YaspGrid} \cxx{GeometryGrid} \cxx{OneDGrid} \cxx{UGGrid}

Input: \cxx{GmshReader} \cxx{StructuredGridFactory}

Output: \cxx{VTKWriter} \cxx{SubSamplingVTKWriter} gnuplot

\module{\cxx{dune-istl}}

\cxx{BlockVector} \cxx{BCRSMatrix}

\cxx{MatrixAdapter} \cxx{Preconditioner}

list of preconditioners

\cxx{Solver} Interface \cxx{InverseOperatorResult}

list of solvers

\module{\cxx{dune-localfunctions}}

local finite element interface -> { local basis interface, local interpolation
  interface, local coefficients interface }

list of local finite elements


\end{multicols*}\end{document}


% tell emacs to use pdflatex
%%% Local Variables:
%%% mode: latex
%%% mode: TeX-PDF
%%% TeX-master: t
%%% mode: flyspell
%%% ispell-local-dictionary: "en_US"
%%% End:
